// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package proto

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TxInput struct {
	// 引用的上一笔交易的交易哈希，创币交易初始化全为0
	TxId []byte `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	// 引用的上一笔交易的输出索引，创币交易初始化为0xFFFFFFFF
	Vout uint32 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	// 解锁脚本
	ScriptSig []byte `protobuf:"bytes,3,opt,name=script_sig,json=scriptSig,proto3" json:"script_sig,omitempty"`
	// 创币交易长度
	CoinbaseDataSize int32 `protobuf:"varint,4,opt,name=coinbase_data_size,json=coinbaseDataSize,proto3" json:"coinbase_data_size,omitempty"`
	// 创币交易（用户可以在这里写下任何东西，可辅助挖矿）
	CoinbaseData         []byte   `protobuf:"bytes,5,opt,name=coinbase_data,json=coinbaseData,proto3" json:"coinbase_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxInput) Reset()         { *m = TxInput{} }
func (m *TxInput) String() string { return proto.CompactTextString(m) }
func (*TxInput) ProtoMessage()    {}
func (*TxInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *TxInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInput.Merge(m, src)
}
func (m *TxInput) XXX_Size() int {
	return m.Size()
}
func (m *TxInput) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInput.DiscardUnknown(m)
}

var xxx_messageInfo_TxInput proto.InternalMessageInfo

type TxOutput struct {
	// 输出金额
	Value uint64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	// 输出地址
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// 锁定脚本
	ScriptPubKey         []byte   `protobuf:"bytes,3,opt,name=script_pub_key,json=scriptPubKey,proto3" json:"script_pub_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxOutput) Reset()         { *m = TxOutput{} }
func (m *TxOutput) String() string { return proto.CompactTextString(m) }
func (*TxOutput) ProtoMessage()    {}
func (*TxOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *TxOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOutput.Merge(m, src)
}
func (m *TxOutput) XXX_Size() int {
	return m.Size()
}
func (m *TxOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOutput.DiscardUnknown(m)
}

var xxx_messageInfo_TxOutput proto.InternalMessageInfo

type Transaction struct {
	// hash by sha256 with 32 bytes
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// 交易输入
	Ins []TxInput `protobuf:"bytes,2,rep,name=ins,proto3" json:"ins"`
	// 交易输出
	Outs []TxOutput `protobuf:"bytes,3,rep,name=outs,proto3" json:"outs"`
	// 时间戳
	Timestamp            int64    `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

type GetHeightReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHeightReq) Reset()         { *m = GetHeightReq{} }
func (m *GetHeightReq) String() string { return proto.CompactTextString(m) }
func (*GetHeightReq) ProtoMessage()    {}
func (*GetHeightReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *GetHeightReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHeightReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHeightReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHeightReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHeightReq.Merge(m, src)
}
func (m *GetHeightReq) XXX_Size() int {
	return m.Size()
}
func (m *GetHeightReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHeightReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetHeightReq proto.InternalMessageInfo

type GetHeightResp struct {
	Height               uint64   `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHeightResp) Reset()         { *m = GetHeightResp{} }
func (m *GetHeightResp) String() string { return proto.CompactTextString(m) }
func (*GetHeightResp) ProtoMessage()    {}
func (*GetHeightResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *GetHeightResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHeightResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHeightResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHeightResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHeightResp.Merge(m, src)
}
func (m *GetHeightResp) XXX_Size() int {
	return m.Size()
}
func (m *GetHeightResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHeightResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetHeightResp proto.InternalMessageInfo

type GetBlocksReq struct {
	StartHeight          uint64   `protobuf:"varint,1,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	EndHeight            uint64   `protobuf:"varint,2,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlocksReq) Reset()         { *m = GetBlocksReq{} }
func (m *GetBlocksReq) String() string { return proto.CompactTextString(m) }
func (*GetBlocksReq) ProtoMessage()    {}
func (*GetBlocksReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *GetBlocksReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlocksReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlocksReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlocksReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlocksReq.Merge(m, src)
}
func (m *GetBlocksReq) XXX_Size() int {
	return m.Size()
}
func (m *GetBlocksReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlocksReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlocksReq proto.InternalMessageInfo

type GetBlocksResp struct {
	Blocks               []byte   `protobuf:"bytes,1,opt,name=blocks,proto3" json:"blocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlocksResp) Reset()         { *m = GetBlocksResp{} }
func (m *GetBlocksResp) String() string { return proto.CompactTextString(m) }
func (*GetBlocksResp) ProtoMessage()    {}
func (*GetBlocksResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *GetBlocksResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlocksResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlocksResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlocksResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlocksResp.Merge(m, src)
}
func (m *GetBlocksResp) XXX_Size() int {
	return m.Size()
}
func (m *GetBlocksResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlocksResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlocksResp proto.InternalMessageInfo

type GetBalanceReq struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBalanceReq) Reset()         { *m = GetBalanceReq{} }
func (m *GetBalanceReq) String() string { return proto.CompactTextString(m) }
func (*GetBalanceReq) ProtoMessage()    {}
func (*GetBalanceReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *GetBalanceReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceReq.Merge(m, src)
}
func (m *GetBalanceReq) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceReq proto.InternalMessageInfo

type GetBalanceResp struct {
	Balance              uint64   `protobuf:"varint,2,opt,name=balance,proto3" json:"balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBalanceResp) Reset()         { *m = GetBalanceResp{} }
func (m *GetBalanceResp) String() string { return proto.CompactTextString(m) }
func (*GetBalanceResp) ProtoMessage()    {}
func (*GetBalanceResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *GetBalanceResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceResp.Merge(m, src)
}
func (m *GetBalanceResp) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceResp proto.InternalMessageInfo

type GetUTXOReq struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUTXOReq) Reset()         { *m = GetUTXOReq{} }
func (m *GetUTXOReq) String() string { return proto.CompactTextString(m) }
func (*GetUTXOReq) ProtoMessage()    {}
func (*GetUTXOReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *GetUTXOReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUTXOReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUTXOReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUTXOReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUTXOReq.Merge(m, src)
}
func (m *GetUTXOReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUTXOReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUTXOReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUTXOReq proto.InternalMessageInfo

type UTXO struct {
	TxHash               []byte   `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Index                int32    `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	TxOut                TxOutput `protobuf:"bytes,3,opt,name=tx_out,json=txOut,proto3" json:"tx_out"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UTXO) Reset()         { *m = UTXO{} }
func (m *UTXO) String() string { return proto.CompactTextString(m) }
func (*UTXO) ProtoMessage()    {}
func (*UTXO) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *UTXO) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UTXO) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UTXO.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UTXO) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UTXO.Merge(m, src)
}
func (m *UTXO) XXX_Size() int {
	return m.Size()
}
func (m *UTXO) XXX_DiscardUnknown() {
	xxx_messageInfo_UTXO.DiscardUnknown(m)
}

var xxx_messageInfo_UTXO proto.InternalMessageInfo

type GetUTXOResp struct {
	Utxos                []UTXO   `protobuf:"bytes,1,rep,name=utxos,proto3" json:"utxos"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUTXOResp) Reset()         { *m = GetUTXOResp{} }
func (m *GetUTXOResp) String() string { return proto.CompactTextString(m) }
func (*GetUTXOResp) ProtoMessage()    {}
func (*GetUTXOResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *GetUTXOResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUTXOResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUTXOResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUTXOResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUTXOResp.Merge(m, src)
}
func (m *GetUTXOResp) XXX_Size() int {
	return m.Size()
}
func (m *GetUTXOResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUTXOResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUTXOResp proto.InternalMessageInfo

type GetTxPoolReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTxPoolReq) Reset()         { *m = GetTxPoolReq{} }
func (m *GetTxPoolReq) String() string { return proto.CompactTextString(m) }
func (*GetTxPoolReq) ProtoMessage()    {}
func (*GetTxPoolReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *GetTxPoolReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxPoolReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxPoolReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxPoolReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxPoolReq.Merge(m, src)
}
func (m *GetTxPoolReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTxPoolReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxPoolReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxPoolReq proto.InternalMessageInfo

type GetTxPoolResp struct {
	TxPool               []byte   `protobuf:"bytes,1,opt,name=tx_pool,json=txPool,proto3" json:"tx_pool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTxPoolResp) Reset()         { *m = GetTxPoolResp{} }
func (m *GetTxPoolResp) String() string { return proto.CompactTextString(m) }
func (*GetTxPoolResp) ProtoMessage()    {}
func (*GetTxPoolResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *GetTxPoolResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxPoolResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxPoolResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxPoolResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxPoolResp.Merge(m, src)
}
func (m *GetTxPoolResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTxPoolResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxPoolResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxPoolResp proto.InternalMessageInfo

type SubmitReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitReq) Reset()         { *m = SubmitReq{} }
func (m *SubmitReq) String() string { return proto.CompactTextString(m) }
func (*SubmitReq) ProtoMessage()    {}
func (*SubmitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *SubmitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitReq.Merge(m, src)
}
func (m *SubmitReq) XXX_Size() int {
	return m.Size()
}
func (m *SubmitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitReq.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitReq proto.InternalMessageInfo

type PostTxReq struct {
	Tx                   Transaction `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PostTxReq) Reset()         { *m = PostTxReq{} }
func (m *PostTxReq) String() string { return proto.CompactTextString(m) }
func (*PostTxReq) ProtoMessage()    {}
func (*PostTxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *PostTxReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostTxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostTxReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostTxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostTxReq.Merge(m, src)
}
func (m *PostTxReq) XXX_Size() int {
	return m.Size()
}
func (m *PostTxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PostTxReq.DiscardUnknown(m)
}

var xxx_messageInfo_PostTxReq proto.InternalMessageInfo

type PostTxResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PostTxResp) Reset()         { *m = PostTxResp{} }
func (m *PostTxResp) String() string { return proto.CompactTextString(m) }
func (*PostTxResp) ProtoMessage()    {}
func (*PostTxResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *PostTxResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PostTxResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PostTxResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PostTxResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostTxResp.Merge(m, src)
}
func (m *PostTxResp) XXX_Size() int {
	return m.Size()
}
func (m *PostTxResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PostTxResp.DiscardUnknown(m)
}

var xxx_messageInfo_PostTxResp proto.InternalMessageInfo

func init() {
	proto.RegisterType((*TxInput)(nil), "TxInput")
	proto.RegisterType((*TxOutput)(nil), "TxOutput")
	proto.RegisterType((*Transaction)(nil), "Transaction")
	proto.RegisterType((*GetHeightReq)(nil), "GetHeightReq")
	proto.RegisterType((*GetHeightResp)(nil), "GetHeightResp")
	proto.RegisterType((*GetBlocksReq)(nil), "GetBlocksReq")
	proto.RegisterType((*GetBlocksResp)(nil), "GetBlocksResp")
	proto.RegisterType((*GetBalanceReq)(nil), "GetBalanceReq")
	proto.RegisterType((*GetBalanceResp)(nil), "GetBalanceResp")
	proto.RegisterType((*GetUTXOReq)(nil), "GetUTXOReq")
	proto.RegisterType((*UTXO)(nil), "UTXO")
	proto.RegisterType((*GetUTXOResp)(nil), "GetUTXOResp")
	proto.RegisterType((*GetTxPoolReq)(nil), "GetTxPoolReq")
	proto.RegisterType((*GetTxPoolResp)(nil), "GetTxPoolResp")
	proto.RegisterType((*SubmitReq)(nil), "SubmitReq")
	proto.RegisterType((*PostTxReq)(nil), "PostTxReq")
	proto.RegisterType((*PostTxResp)(nil), "PostTxResp")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xdd, 0x6a, 0xdb, 0x48,
	0x14, 0x96, 0x6c, 0xcb, 0x8e, 0x8e, 0x64, 0xef, 0x32, 0x1b, 0x76, 0x8d, 0xd9, 0xd5, 0x3a, 0x93,
	0x25, 0xeb, 0x2c, 0x41, 0x59, 0xd2, 0xcb, 0x5e, 0x35, 0x14, 0x92, 0xd0, 0x8b, 0x18, 0xc5, 0x85,
	0x52, 0x28, 0xaa, 0x6c, 0x0d, 0xb6, 0x88, 0xa3, 0x51, 0x3c, 0xa3, 0xa0, 0xe4, 0x01, 0x7a, 0xd7,
	0xfb, 0x3e, 0x40, 0x2f, 0xfa, 0x28, 0xb9, 0xec, 0x13, 0x94, 0xc4, 0x7d, 0x81, 0x3e, 0x42, 0x99,
	0x1f, 0xd9, 0x32, 0x94, 0x5e, 0x79, 0xbe, 0x39, 0x9f, 0xce, 0xf9, 0xe6, 0xfb, 0x0e, 0x06, 0x3b,
	0xca, 0x12, 0x3f, 0x5b, 0x50, 0x4e, 0x7b, 0xdb, 0x53, 0x3a, 0xa5, 0xf2, 0x78, 0x28, 0x4e, 0xea,
	0x16, 0x7f, 0x34, 0xa1, 0x35, 0x2a, 0xce, 0xd2, 0x2c, 0xe7, 0xe8, 0x37, 0xb0, 0x78, 0x11, 0x26,
	0x71, 0xd7, 0xec, 0x9b, 0x03, 0x37, 0x68, 0xf0, 0xe2, 0x2c, 0x46, 0x08, 0x1a, 0x37, 0x34, 0xe7,
	0xdd, 0x5a, 0xdf, 0x1c, 0xb4, 0x03, 0x79, 0x46, 0x7f, 0x01, 0xb0, 0xc9, 0x22, 0xc9, 0x78, 0xc8,
	0x92, 0x69, 0xb7, 0x2e, 0xd9, 0xb6, 0xba, 0xb9, 0x48, 0xa6, 0xe8, 0x00, 0xd0, 0x84, 0x26, 0xe9,
	0x38, 0x62, 0x24, 0x8c, 0x23, 0x1e, 0x85, 0x2c, 0xb9, 0x23, 0xdd, 0x46, 0xdf, 0x1c, 0x58, 0xc1,
	0xaf, 0x65, 0xe5, 0x79, 0xc4, 0xa3, 0x8b, 0xe4, 0x8e, 0xa0, 0x5d, 0x68, 0x6f, 0xb0, 0xbb, 0x96,
	0xec, 0xe7, 0x56, 0x89, 0xf8, 0x2d, 0x6c, 0x8d, 0x8a, 0xf3, 0x9c, 0x0b, 0x99, 0xdb, 0x60, 0xdd,
	0x44, 0xf3, 0x9c, 0x48, 0x99, 0x8d, 0x40, 0x01, 0xd4, 0x85, 0x56, 0x14, 0xc7, 0x0b, 0xc2, 0x98,
	0x94, 0x6a, 0x07, 0x25, 0x44, 0xff, 0x40, 0x47, 0xab, 0xcd, 0xf2, 0x71, 0x78, 0x49, 0x6e, 0xb5,
	0x62, 0x57, 0xdd, 0x0e, 0xf3, 0xf1, 0x0b, 0x72, 0x8b, 0xdf, 0x99, 0xe0, 0x8c, 0x16, 0x51, 0xca,
	0xa2, 0x09, 0x4f, 0x68, 0x2a, 0xde, 0x3d, 0x8b, 0xd8, 0xac, 0xf4, 0x42, 0x9c, 0x51, 0x1f, 0xea,
	0x49, 0x2a, 0xfa, 0xd7, 0x07, 0xce, 0xd1, 0x96, 0xaf, 0x7d, 0x3b, 0x6e, 0xdc, 0x7f, 0xf9, 0xdb,
	0x08, 0x44, 0x09, 0xed, 0x42, 0x83, 0xe6, 0x9c, 0x75, 0xeb, 0x92, 0x62, 0xfb, 0xa5, 0x68, 0xcd,
	0x91, 0x45, 0xf4, 0x27, 0xd8, 0x3c, 0xb9, 0x22, 0x8c, 0x47, 0x57, 0x99, 0xb4, 0xa5, 0x1e, 0xac,
	0x2f, 0x70, 0x07, 0xdc, 0x13, 0xc2, 0x4f, 0x49, 0x32, 0x9d, 0xf1, 0x80, 0x5c, 0xe3, 0x7f, 0xa1,
	0x5d, 0xc1, 0x2c, 0x43, 0xbf, 0x43, 0x73, 0x26, 0x91, 0x36, 0x40, 0x23, 0x3c, 0x94, 0x1f, 0x1e,
	0xcf, 0xe9, 0xe4, 0x92, 0x05, 0xe4, 0x1a, 0xed, 0x80, 0xcb, 0x78, 0xb4, 0xe0, 0xe1, 0x06, 0xdb,
	0x91, 0x77, 0xaa, 0x9d, 0x08, 0x92, 0xa4, 0x71, 0x49, 0xa8, 0x49, 0x82, 0x4d, 0xd2, 0x58, 0x95,
	0xf5, 0xe8, 0xb2, 0xa3, 0x1a, 0x3d, 0x96, 0x48, 0xdb, 0xa2, 0x11, 0xde, 0x57, 0xc4, 0x68, 0x1e,
	0xa5, 0x13, 0x22, 0x66, 0x57, 0xd2, 0x30, 0x37, 0xd2, 0xc0, 0xff, 0x41, 0xa7, 0x4a, 0x65, 0x99,
	0xe0, 0x8e, 0x15, 0xd4, 0x0a, 0x4a, 0x88, 0xf7, 0x00, 0x4e, 0x08, 0x7f, 0x39, 0x7a, 0x75, 0xfe,
	0xf3, 0x9e, 0x6f, 0xa0, 0x21, 0x48, 0xe8, 0x0f, 0x68, 0xf1, 0x22, 0xac, 0xc4, 0xd6, 0xe4, 0xc5,
	0xa9, 0x08, 0x6e, 0x1b, 0xac, 0x24, 0x8d, 0x49, 0x21, 0x07, 0x58, 0x81, 0x02, 0x68, 0x0f, 0x9a,
	0xbc, 0x08, 0xc5, 0x72, 0x8b, 0x85, 0xf8, 0x41, 0x5c, 0x16, 0x17, 0x18, 0xff, 0x0f, 0xce, 0x4a,
	0x06, 0xcb, 0xd0, 0x0e, 0x58, 0x39, 0x2f, 0xa8, 0x50, 0x21, 0x42, 0xb6, 0x7c, 0x51, 0x29, 0xbf,
	0x90, 0x15, 0x9d, 0xe1, 0xa8, 0x18, 0x52, 0x3a, 0x17, 0x19, 0x0e, 0xa4, 0x3f, 0x25, 0x66, 0x99,
	0x56, 0x9a, 0x51, 0x3a, 0x5f, 0x2b, 0x15, 0x45, 0xec, 0x80, 0x7d, 0x91, 0x8f, 0xaf, 0x12, 0x19,
	0xfd, 0x21, 0xd8, 0x43, 0xca, 0xf8, 0xa8, 0x10, 0xcf, 0xc7, 0x50, 0xe3, 0x85, 0x64, 0x3b, 0x47,
	0xae, 0x5f, 0x59, 0x55, 0x3d, 0xba, 0xc6, 0x0b, 0xec, 0x02, 0x94, 0x1f, 0xb0, 0xec, 0xe8, 0x7d,
	0x0d, 0xea, 0xcf, 0xb2, 0x04, 0x1d, 0x80, 0xbd, 0xda, 0x20, 0xd4, 0xf6, 0xab, 0xdb, 0xd5, 0xeb,
	0xf8, 0x1b, 0xcb, 0x85, 0x0d, 0xcd, 0x56, 0xa1, 0x2b, 0xf6, 0x6a, 0xa5, 0x14, 0x7b, 0xbd, 0x0f,
	0xd8, 0x40, 0x87, 0x32, 0x22, 0x1d, 0x27, 0x52, 0xf5, 0xd5, 0x1a, 0xf4, 0x7e, 0xf1, 0x37, 0xb3,
	0xc6, 0x06, 0xda, 0x83, 0x96, 0x36, 0x13, 0x39, 0xfe, 0x3a, 0xdd, 0x9e, 0xeb, 0x57, 0x3c, 0x5e,
	0xc9, 0x50, 0x96, 0x29, 0x19, 0x2b, 0x3b, 0x95, 0x8c, 0xb5, 0x9b, 0xd8, 0x40, 0xbb, 0xd0, 0x54,
	0x0f, 0x47, 0xe0, 0xaf, 0x2c, 0xeb, 0x39, 0xfe, 0xda, 0x0d, 0x6c, 0x1c, 0xef, 0xdf, 0x3f, 0x7a,
	0xc6, 0xc3, 0xa3, 0x67, 0x7e, 0x7b, 0xf4, 0xcc, 0x4f, 0x4b, 0xcf, 0xbc, 0x5f, 0x7a, 0xe6, 0xe7,
	0xa5, 0x67, 0x3e, 0x2c, 0x3d, 0xf3, 0xc3, 0x57, 0xcf, 0x78, 0xdd, 0xf2, 0x9f, 0xca, 0xbf, 0xc5,
	0x71, 0x53, 0xfe, 0x3c, 0xf9, 0x1e, 0x00, 0x00, 0xff, 0xff, 0x62, 0xba, 0x45, 0xb3, 0x40, 0x05,
	0x00, 0x00,
}

func (this *TxInput) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TxInput)
	if !ok {
		that2, ok := that.(TxInput)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TxInput")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TxInput but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TxInput but is not nil && this == nil")
	}
	if !bytes.Equal(this.TxId, that1.TxId) {
		return fmt.Errorf("TxId this(%v) Not Equal that(%v)", this.TxId, that1.TxId)
	}
	if this.Vout != that1.Vout {
		return fmt.Errorf("Vout this(%v) Not Equal that(%v)", this.Vout, that1.Vout)
	}
	if !bytes.Equal(this.ScriptSig, that1.ScriptSig) {
		return fmt.Errorf("ScriptSig this(%v) Not Equal that(%v)", this.ScriptSig, that1.ScriptSig)
	}
	if this.CoinbaseDataSize != that1.CoinbaseDataSize {
		return fmt.Errorf("CoinbaseDataSize this(%v) Not Equal that(%v)", this.CoinbaseDataSize, that1.CoinbaseDataSize)
	}
	if !bytes.Equal(this.CoinbaseData, that1.CoinbaseData) {
		return fmt.Errorf("CoinbaseData this(%v) Not Equal that(%v)", this.CoinbaseData, that1.CoinbaseData)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *TxInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxInput)
	if !ok {
		that2, ok := that.(TxInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.TxId, that1.TxId) {
		return false
	}
	if this.Vout != that1.Vout {
		return false
	}
	if !bytes.Equal(this.ScriptSig, that1.ScriptSig) {
		return false
	}
	if this.CoinbaseDataSize != that1.CoinbaseDataSize {
		return false
	}
	if !bytes.Equal(this.CoinbaseData, that1.CoinbaseData) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TxOutput) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TxOutput)
	if !ok {
		that2, ok := that.(TxOutput)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TxOutput")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TxOutput but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TxOutput but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if !bytes.Equal(this.ScriptPubKey, that1.ScriptPubKey) {
		return fmt.Errorf("ScriptPubKey this(%v) Not Equal that(%v)", this.ScriptPubKey, that1.ScriptPubKey)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *TxOutput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxOutput)
	if !ok {
		that2, ok := that.(TxOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.ScriptPubKey, that1.ScriptPubKey) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Transaction) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Transaction")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Transaction but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Transaction but is not nil && this == nil")
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return fmt.Errorf("Hash this(%v) Not Equal that(%v)", this.Hash, that1.Hash)
	}
	if len(this.Ins) != len(that1.Ins) {
		return fmt.Errorf("Ins this(%v) Not Equal that(%v)", len(this.Ins), len(that1.Ins))
	}
	for i := range this.Ins {
		if !this.Ins[i].Equal(&that1.Ins[i]) {
			return fmt.Errorf("Ins this[%v](%v) Not Equal that[%v](%v)", i, this.Ins[i], i, that1.Ins[i])
		}
	}
	if len(this.Outs) != len(that1.Outs) {
		return fmt.Errorf("Outs this(%v) Not Equal that(%v)", len(this.Outs), len(that1.Outs))
	}
	for i := range this.Outs {
		if !this.Outs[i].Equal(&that1.Outs[i]) {
			return fmt.Errorf("Outs this[%v](%v) Not Equal that[%v](%v)", i, this.Outs[i], i, that1.Outs[i])
		}
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Transaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	if len(this.Ins) != len(that1.Ins) {
		return false
	}
	for i := range this.Ins {
		if !this.Ins[i].Equal(&that1.Ins[i]) {
			return false
		}
	}
	if len(this.Outs) != len(that1.Outs) {
		return false
	}
	for i := range this.Outs {
		if !this.Outs[i].Equal(&that1.Outs[i]) {
			return false
		}
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetHeightReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetHeightReq)
	if !ok {
		that2, ok := that.(GetHeightReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetHeightReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetHeightReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetHeightReq but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetHeightReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetHeightReq)
	if !ok {
		that2, ok := that.(GetHeightReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetHeightResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetHeightResp)
	if !ok {
		that2, ok := that.(GetHeightResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetHeightResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetHeightResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetHeightResp but is not nil && this == nil")
	}
	if this.Height != that1.Height {
		return fmt.Errorf("Height this(%v) Not Equal that(%v)", this.Height, that1.Height)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetHeightResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetHeightResp)
	if !ok {
		that2, ok := that.(GetHeightResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetBlocksReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetBlocksReq)
	if !ok {
		that2, ok := that.(GetBlocksReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetBlocksReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetBlocksReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetBlocksReq but is not nil && this == nil")
	}
	if this.StartHeight != that1.StartHeight {
		return fmt.Errorf("StartHeight this(%v) Not Equal that(%v)", this.StartHeight, that1.StartHeight)
	}
	if this.EndHeight != that1.EndHeight {
		return fmt.Errorf("EndHeight this(%v) Not Equal that(%v)", this.EndHeight, that1.EndHeight)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetBlocksReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetBlocksReq)
	if !ok {
		that2, ok := that.(GetBlocksReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartHeight != that1.StartHeight {
		return false
	}
	if this.EndHeight != that1.EndHeight {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetBlocksResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetBlocksResp)
	if !ok {
		that2, ok := that.(GetBlocksResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetBlocksResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetBlocksResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetBlocksResp but is not nil && this == nil")
	}
	if !bytes.Equal(this.Blocks, that1.Blocks) {
		return fmt.Errorf("Blocks this(%v) Not Equal that(%v)", this.Blocks, that1.Blocks)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetBlocksResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetBlocksResp)
	if !ok {
		that2, ok := that.(GetBlocksResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Blocks, that1.Blocks) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetBalanceReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetBalanceReq)
	if !ok {
		that2, ok := that.(GetBalanceReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetBalanceReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetBalanceReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetBalanceReq but is not nil && this == nil")
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetBalanceReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetBalanceReq)
	if !ok {
		that2, ok := that.(GetBalanceReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetBalanceResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetBalanceResp)
	if !ok {
		that2, ok := that.(GetBalanceResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetBalanceResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetBalanceResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetBalanceResp but is not nil && this == nil")
	}
	if this.Balance != that1.Balance {
		return fmt.Errorf("Balance this(%v) Not Equal that(%v)", this.Balance, that1.Balance)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetBalanceResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetBalanceResp)
	if !ok {
		that2, ok := that.(GetBalanceResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetUTXOReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUTXOReq)
	if !ok {
		that2, ok := that.(GetUTXOReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUTXOReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUTXOReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUTXOReq but is not nil && this == nil")
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetUTXOReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUTXOReq)
	if !ok {
		that2, ok := that.(GetUTXOReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *UTXO) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UTXO)
	if !ok {
		that2, ok := that.(UTXO)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UTXO")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UTXO but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UTXO but is not nil && this == nil")
	}
	if !bytes.Equal(this.TxHash, that1.TxHash) {
		return fmt.Errorf("TxHash this(%v) Not Equal that(%v)", this.TxHash, that1.TxHash)
	}
	if this.Index != that1.Index {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if !this.TxOut.Equal(&that1.TxOut) {
		return fmt.Errorf("TxOut this(%v) Not Equal that(%v)", this.TxOut, that1.TxOut)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *UTXO) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UTXO)
	if !ok {
		that2, ok := that.(UTXO)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.TxHash, that1.TxHash) {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !this.TxOut.Equal(&that1.TxOut) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetUTXOResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetUTXOResp)
	if !ok {
		that2, ok := that.(GetUTXOResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetUTXOResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetUTXOResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetUTXOResp but is not nil && this == nil")
	}
	if len(this.Utxos) != len(that1.Utxos) {
		return fmt.Errorf("Utxos this(%v) Not Equal that(%v)", len(this.Utxos), len(that1.Utxos))
	}
	for i := range this.Utxos {
		if !this.Utxos[i].Equal(&that1.Utxos[i]) {
			return fmt.Errorf("Utxos this[%v](%v) Not Equal that[%v](%v)", i, this.Utxos[i], i, that1.Utxos[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetUTXOResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUTXOResp)
	if !ok {
		that2, ok := that.(GetUTXOResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Utxos) != len(that1.Utxos) {
		return false
	}
	for i := range this.Utxos {
		if !this.Utxos[i].Equal(&that1.Utxos[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetTxPoolReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTxPoolReq)
	if !ok {
		that2, ok := that.(GetTxPoolReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTxPoolReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTxPoolReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTxPoolReq but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetTxPoolReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTxPoolReq)
	if !ok {
		that2, ok := that.(GetTxPoolReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GetTxPoolResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GetTxPoolResp)
	if !ok {
		that2, ok := that.(GetTxPoolResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GetTxPoolResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GetTxPoolResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GetTxPoolResp but is not nil && this == nil")
	}
	if !bytes.Equal(this.TxPool, that1.TxPool) {
		return fmt.Errorf("TxPool this(%v) Not Equal that(%v)", this.TxPool, that1.TxPool)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GetTxPoolResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTxPoolResp)
	if !ok {
		that2, ok := that.(GetTxPoolResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.TxPool, that1.TxPool) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SubmitReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SubmitReq)
	if !ok {
		that2, ok := that.(SubmitReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SubmitReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SubmitReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SubmitReq but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *SubmitReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubmitReq)
	if !ok {
		that2, ok := that.(SubmitReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PostTxReq) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PostTxReq)
	if !ok {
		that2, ok := that.(PostTxReq)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PostTxReq")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PostTxReq but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PostTxReq but is not nil && this == nil")
	}
	if !this.Tx.Equal(&that1.Tx) {
		return fmt.Errorf("Tx this(%v) Not Equal that(%v)", this.Tx, that1.Tx)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *PostTxReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostTxReq)
	if !ok {
		that2, ok := that.(PostTxReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tx.Equal(&that1.Tx) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PostTxResp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PostTxResp)
	if !ok {
		that2, ok := that.(PostTxResp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PostTxResp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PostTxResp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PostTxResp but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *PostTxResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PostTxResp)
	if !ok {
		that2, ok := that.(PostTxResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TxInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto.TxInput{")
	s = append(s, "TxId: "+fmt.Sprintf("%#v", this.TxId)+",\n")
	s = append(s, "Vout: "+fmt.Sprintf("%#v", this.Vout)+",\n")
	s = append(s, "ScriptSig: "+fmt.Sprintf("%#v", this.ScriptSig)+",\n")
	s = append(s, "CoinbaseDataSize: "+fmt.Sprintf("%#v", this.CoinbaseDataSize)+",\n")
	s = append(s, "CoinbaseData: "+fmt.Sprintf("%#v", this.CoinbaseData)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TxOutput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.TxOutput{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "ScriptPubKey: "+fmt.Sprintf("%#v", this.ScriptPubKey)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Transaction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.Transaction{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	if this.Ins != nil {
		vs := make([]TxInput, len(this.Ins))
		for i := range vs {
			vs[i] = this.Ins[i]
		}
		s = append(s, "Ins: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Outs != nil {
		vs := make([]TxOutput, len(this.Outs))
		for i := range vs {
			vs[i] = this.Outs[i]
		}
		s = append(s, "Outs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetHeightReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto.GetHeightReq{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetHeightResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetHeightResp{")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetBlocksReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.GetBlocksReq{")
	s = append(s, "StartHeight: "+fmt.Sprintf("%#v", this.StartHeight)+",\n")
	s = append(s, "EndHeight: "+fmt.Sprintf("%#v", this.EndHeight)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetBlocksResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetBlocksResp{")
	s = append(s, "Blocks: "+fmt.Sprintf("%#v", this.Blocks)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetBalanceReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetBalanceReq{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetBalanceResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetBalanceResp{")
	s = append(s, "Balance: "+fmt.Sprintf("%#v", this.Balance)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUTXOReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetUTXOReq{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UTXO) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.UTXO{")
	s = append(s, "TxHash: "+fmt.Sprintf("%#v", this.TxHash)+",\n")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "TxOut: "+strings.Replace(this.TxOut.GoString(), `&`, ``, 1)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUTXOResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetUTXOResp{")
	if this.Utxos != nil {
		vs := make([]UTXO, len(this.Utxos))
		for i := range vs {
			vs[i] = this.Utxos[i]
		}
		s = append(s, "Utxos: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTxPoolReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto.GetTxPoolReq{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTxPoolResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.GetTxPoolResp{")
	s = append(s, "TxPool: "+fmt.Sprintf("%#v", this.TxPool)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubmitReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto.SubmitReq{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PostTxReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.PostTxReq{")
	s = append(s, "Tx: "+strings.Replace(this.Tx.GoString(), `&`, ``, 1)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PostTxResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto.PostTxResp{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApiClient is the client API for Api service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApiClient interface {
	// GetHeight 获取区块高度
	GetHeight(ctx context.Context, in *GetHeightReq, opts ...grpc.CallOption) (*GetHeightResp, error)
	// GetBlocks 获取指定范围内的区块
	GetBlocks(ctx context.Context, in *GetBlocksReq, opts ...grpc.CallOption) (*GetBlocksResp, error)
	// GetBalance 获取指定地址的余额
	GetBalance(ctx context.Context, in *GetBalanceReq, opts ...grpc.CallOption) (*GetBalanceResp, error)
	// GetUTXO 获取指定地址的未花费输出
	GetUTXO(ctx context.Context, in *GetUTXOReq, opts ...grpc.CallOption) (*GetUTXOResp, error)
	// GetTxPool 返回交易池对象
	GetTxPool(ctx context.Context, in *GetTxPoolReq, opts ...grpc.CallOption) (*GetTxPoolResp, error)
	// PostTxReq 发起交易
	PostTx(ctx context.Context, in *PostTxReq, opts ...grpc.CallOption) (*PostTxResp, error)
}

type apiClient struct {
	cc *grpc.ClientConn
}

func NewApiClient(cc *grpc.ClientConn) ApiClient {
	return &apiClient{cc}
}

func (c *apiClient) GetHeight(ctx context.Context, in *GetHeightReq, opts ...grpc.CallOption) (*GetHeightResp, error) {
	out := new(GetHeightResp)
	err := c.cc.Invoke(ctx, "/Api/GetHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetBlocks(ctx context.Context, in *GetBlocksReq, opts ...grpc.CallOption) (*GetBlocksResp, error) {
	out := new(GetBlocksResp)
	err := c.cc.Invoke(ctx, "/Api/GetBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetBalance(ctx context.Context, in *GetBalanceReq, opts ...grpc.CallOption) (*GetBalanceResp, error) {
	out := new(GetBalanceResp)
	err := c.cc.Invoke(ctx, "/Api/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetUTXO(ctx context.Context, in *GetUTXOReq, opts ...grpc.CallOption) (*GetUTXOResp, error) {
	out := new(GetUTXOResp)
	err := c.cc.Invoke(ctx, "/Api/GetUTXO", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetTxPool(ctx context.Context, in *GetTxPoolReq, opts ...grpc.CallOption) (*GetTxPoolResp, error) {
	out := new(GetTxPoolResp)
	err := c.cc.Invoke(ctx, "/Api/GetTxPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) PostTx(ctx context.Context, in *PostTxReq, opts ...grpc.CallOption) (*PostTxResp, error) {
	out := new(PostTxResp)
	err := c.cc.Invoke(ctx, "/Api/PostTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServer is the server API for Api service.
type ApiServer interface {
	// GetHeight 获取区块高度
	GetHeight(context.Context, *GetHeightReq) (*GetHeightResp, error)
	// GetBlocks 获取指定范围内的区块
	GetBlocks(context.Context, *GetBlocksReq) (*GetBlocksResp, error)
	// GetBalance 获取指定地址的余额
	GetBalance(context.Context, *GetBalanceReq) (*GetBalanceResp, error)
	// GetUTXO 获取指定地址的未花费输出
	GetUTXO(context.Context, *GetUTXOReq) (*GetUTXOResp, error)
	// GetTxPool 返回交易池对象
	GetTxPool(context.Context, *GetTxPoolReq) (*GetTxPoolResp, error)
	// PostTxReq 发起交易
	PostTx(context.Context, *PostTxReq) (*PostTxResp, error)
}

// UnimplementedApiServer can be embedded to have forward compatible implementations.
type UnimplementedApiServer struct {
}

func (*UnimplementedApiServer) GetHeight(ctx context.Context, req *GetHeightReq) (*GetHeightResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeight not implemented")
}
func (*UnimplementedApiServer) GetBlocks(ctx context.Context, req *GetBlocksReq) (*GetBlocksResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocks not implemented")
}
func (*UnimplementedApiServer) GetBalance(ctx context.Context, req *GetBalanceReq) (*GetBalanceResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (*UnimplementedApiServer) GetUTXO(ctx context.Context, req *GetUTXOReq) (*GetUTXOResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUTXO not implemented")
}
func (*UnimplementedApiServer) GetTxPool(ctx context.Context, req *GetTxPoolReq) (*GetTxPoolResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxPool not implemented")
}
func (*UnimplementedApiServer) PostTx(ctx context.Context, req *PostTxReq) (*PostTxResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostTx not implemented")
}

func RegisterApiServer(s *grpc.Server, srv ApiServer) {
	s.RegisterService(&_Api_serviceDesc, srv)
}

func _Api_GetHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHeightReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Api/GetHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetHeight(ctx, req.(*GetHeightReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlocksReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Api/GetBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetBlocks(ctx, req.(*GetBlocksReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Api/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetBalance(ctx, req.(*GetBalanceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetUTXO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUTXOReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetUTXO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Api/GetUTXO",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetUTXO(ctx, req.(*GetUTXOReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetTxPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxPoolReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetTxPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Api/GetTxPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetTxPool(ctx, req.(*GetTxPoolReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_PostTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostTxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).PostTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Api/PostTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).PostTx(ctx, req.(*PostTxReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Api_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Api",
	HandlerType: (*ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHeight",
			Handler:    _Api_GetHeight_Handler,
		},
		{
			MethodName: "GetBlocks",
			Handler:    _Api_GetBlocks_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Api_GetBalance_Handler,
		},
		{
			MethodName: "GetUTXO",
			Handler:    _Api_GetUTXO_Handler,
		},
		{
			MethodName: "GetTxPool",
			Handler:    _Api_GetTxPool_Handler,
		},
		{
			MethodName: "PostTx",
			Handler:    _Api_PostTx_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *TxInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CoinbaseData) > 0 {
		i -= len(m.CoinbaseData)
		copy(dAtA[i:], m.CoinbaseData)
		i = encodeVarintApi(dAtA, i, uint64(len(m.CoinbaseData)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CoinbaseDataSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CoinbaseDataSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ScriptSig) > 0 {
		i -= len(m.ScriptSig)
		copy(dAtA[i:], m.ScriptSig)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ScriptSig)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Vout != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Vout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ScriptPubKey) > 0 {
		i -= len(m.ScriptPubKey)
		copy(dAtA[i:], m.ScriptPubKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ScriptPubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Value != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Outs) > 0 {
		for iNdEx := len(m.Outs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ins) > 0 {
		for iNdEx := len(m.Ins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetHeightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHeightReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHeightReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetHeightResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHeightResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHeightResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Height != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBlocksReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlocksReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlocksReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndHeight != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.StartHeight != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBlocksResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlocksResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlocksResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Blocks) > 0 {
		i -= len(m.Blocks)
		copy(dAtA[i:], m.Blocks)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Blocks)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Balance != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Balance))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *GetUTXOReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUTXOReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUTXOReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UTXO) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UTXO) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UTXO) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TxOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Index != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUTXOResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUTXOResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUTXOResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Utxos) > 0 {
		for iNdEx := len(m.Utxos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Utxos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetTxPoolReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxPoolReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxPoolReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetTxPoolResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxPoolResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxPoolResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TxPool) > 0 {
		i -= len(m.TxPool)
		copy(dAtA[i:], m.TxPool)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TxPool)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubmitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PostTxReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostTxReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PostTxReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PostTxResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PostTxResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PostTxResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TxInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Vout != 0 {
		n += 1 + sovApi(uint64(m.Vout))
	}
	l = len(m.ScriptSig)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CoinbaseDataSize != 0 {
		n += 1 + sovApi(uint64(m.CoinbaseDataSize))
	}
	l = len(m.CoinbaseData)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovApi(uint64(m.Value))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ScriptPubKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Ins) > 0 {
		for _, e := range m.Ins {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Outs) > 0 {
		for _, e := range m.Outs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetHeightReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetHeightResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovApi(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlocksReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartHeight != 0 {
		n += 1 + sovApi(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovApi(uint64(m.EndHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlocksResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Blocks)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBalanceReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBalanceResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != 0 {
		n += 1 + sovApi(uint64(m.Balance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUTXOReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UTXO) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	l = m.TxOut.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUTXOResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Utxos) > 0 {
		for _, e := range m.Utxos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTxPoolReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTxPoolResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxPool)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PostTxReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Tx.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PostTxResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = append(m.TxId[:0], dAtA[iNdEx:postIndex]...)
			if m.TxId == nil {
				m.TxId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vout", wireType)
			}
			m.Vout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptSig = append(m.ScriptSig[:0], dAtA[iNdEx:postIndex]...)
			if m.ScriptSig == nil {
				m.ScriptSig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinbaseDataSize", wireType)
			}
			m.CoinbaseDataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinbaseDataSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinbaseData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinbaseData = append(m.CoinbaseData[:0], dAtA[iNdEx:postIndex]...)
			if m.CoinbaseData == nil {
				m.CoinbaseData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptPubKey = append(m.ScriptPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ScriptPubKey == nil {
				m.ScriptPubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ins = append(m.Ins, TxInput{})
			if err := m.Ins[len(m.Ins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outs = append(m.Outs, TxOutput{})
			if err := m.Outs[len(m.Outs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHeightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHeightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHeightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHeightResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHeightResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHeightResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlocksReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlocksReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlocksReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlocksResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlocksResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlocksResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks[:0], dAtA[iNdEx:postIndex]...)
			if m.Blocks == nil {
				m.Blocks = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUTXOReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUTXOReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUTXOReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UTXO) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UTXO: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UTXO: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUTXOResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUTXOResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUTXOResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Utxos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Utxos = append(m.Utxos, UTXO{})
			if err := m.Utxos[len(m.Utxos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxPoolReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxPoolReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxPoolReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxPoolResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxPoolResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxPoolResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPool", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxPool = append(m.TxPool[:0], dAtA[iNdEx:postIndex]...)
			if m.TxPool == nil {
				m.TxPool = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostTxReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostTxReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostTxReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PostTxResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PostTxResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PostTxResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
